$date
	Thu Apr  8 16:09:30 2021
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module main $end
$var wire 32 ! writedata [31:0] $end
$var reg 1 " clk $end
$var reg 1 # res $end
$scope module CPU $end
$var wire 1 " clk $end
$var wire 1 # rst $end
$var wire 1 $ zero $end
$var wire 32 % writedata [31:0] $end
$var wire 32 & sigext [31:0] $end
$var wire 32 ' readdata [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 ) memtoreg $end
$var wire 1 * memread $end
$var wire 32 + inst [31:0] $end
$var wire 10 , funct [9:0] $end
$var wire 32 - data2 [31:0] $end
$var wire 32 . data1 [31:0] $end
$var wire 1 / branch $end
$var wire 1 0 alusrc $end
$var wire 32 1 aluout [31:0] $end
$var wire 2 2 aluop [1:0] $end
$scope module Decode $end
$var wire 1 " clk $end
$var wire 32 3 writedata [31:0] $end
$var wire 5 4 rs2 [4:0] $end
$var wire 5 5 rs1 [4:0] $end
$var wire 1 6 regwrite $end
$var wire 5 7 rd [4:0] $end
$var wire 7 8 opcode [6:0] $end
$var wire 1 ( memwrite $end
$var wire 1 ) memtoreg $end
$var wire 1 * memread $end
$var wire 32 9 inst [31:0] $end
$var wire 10 : funct [9:0] $end
$var wire 32 ; data2 [31:0] $end
$var wire 32 < data1 [31:0] $end
$var wire 1 / branch $end
$var wire 1 0 alusrc $end
$var wire 2 = aluop [1:0] $end
$var wire 32 > ImmGen [31:0] $end
$scope module Registers $end
$var wire 1 " clk $end
$var wire 32 ? read_data1 [31:0] $end
$var wire 32 @ read_data2 [31:0] $end
$var wire 5 A read_reg1 [4:0] $end
$var wire 5 B read_reg2 [4:0] $end
$var wire 5 C writereg [4:0] $end
$var wire 32 D writedata [31:0] $end
$var wire 1 6 regwrite $end
$var integer 32 E i [31:0] $end
$upscope $end
$scope module control $end
$var wire 7 F opcode [6:0] $end
$var wire 32 G inst [31:0] $end
$var reg 32 H ImmGen [31:0] $end
$var reg 2 I aluop [1:0] $end
$var reg 1 0 alusrc $end
$var reg 1 / branch $end
$var reg 1 * memread $end
$var reg 1 ) memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 6 regwrite $end
$upscope $end
$upscope $end
$scope module Execute $end
$var wire 32 J ImmGen [31:0] $end
$var wire 2 K aluop [1:0] $end
$var wire 1 0 alusrc $end
$var wire 10 L funct [9:0] $end
$var wire 32 M in1 [31:0] $end
$var wire 32 N in2 [31:0] $end
$var wire 1 $ zero $end
$var wire 32 O aluout [31:0] $end
$var wire 4 P aluctrl [3:0] $end
$var wire 32 Q alu_B [31:0] $end
$scope module alu $end
$var wire 32 R A [31:0] $end
$var wire 32 S B [31:0] $end
$var wire 1 $ zero $end
$var wire 4 T alucontrol [3:0] $end
$var reg 32 U aluout [31:0] $end
$upscope $end
$scope module alucontrol $end
$var wire 2 V aluop [1:0] $end
$var wire 10 W funct [9:0] $end
$var wire 8 X funct7 [7:0] $end
$var wire 3 Y funct3 [2:0] $end
$var reg 4 Z alucontrol [3:0] $end
$upscope $end
$upscope $end
$scope module Fetch $end
$var wire 1 / branch $end
$var wire 1 " clk $end
$var wire 32 [ inst [31:0] $end
$var wire 1 # rst $end
$var wire 32 \ sigext [31:0] $end
$var wire 1 $ zero $end
$var wire 32 ] pc_4 [31:0] $end
$var wire 32 ^ pc [31:0] $end
$var wire 32 _ new_pc [31:0] $end
$scope module program_counter $end
$var wire 1 " clk $end
$var wire 32 ` pc_in [31:0] $end
$var wire 1 # rst $end
$var reg 32 a pc_out [31:0] $end
$upscope $end
$upscope $end
$scope module Memory $end
$var wire 32 b address [31:0] $end
$var wire 1 " clk $end
$var wire 1 * memread $end
$var wire 1 ( memwrite $end
$var wire 32 c writedata [31:0] $end
$var wire 32 d readdata [31:0] $end
$var integer 32 e i [31:0] $end
$upscope $end
$scope module Writeback $end
$var wire 32 f aluout [31:0] $end
$var wire 1 ) memtoreg $end
$var wire 32 g readdata [31:0] $end
$var reg 32 h write_data [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx h
bx g
bx f
b10000000 e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
b0xxxxxxx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
b100000 E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
x6
bx 5
bx 4
bx 3
bx 2
bx 1
x0
x/
bx .
bx -
bx ,
bx +
x*
x)
x(
bx '
bx &
bx %
x$
0#
0"
bx !
$end
#1
b10 P
b10 T
b10 Z
b0 !
b0 %
b0 3
b0 D
b0 h
b100 _
b100 `
b0 '
b0 d
b0 g
b0 Q
b0 S
1$
b0 1
b0 O
b0 U
b0 b
b0 f
b0 &
b0 >
b0 H
b0 J
b0 \
b0 2
b0 =
b0 I
b0 K
b0 V
0/
0(
0*
06
0)
00
b0 Y
b0 X
b0 ,
b0 :
b0 L
b0 W
b0 7
b0 C
b0 -
b0 ;
b0 @
b0 N
b0 c
b0 4
b0 B
b0 .
b0 <
b0 ?
b0 M
b0 R
b0 5
b0 A
b0 8
b0 F
b0 +
b0 9
b0 G
b0 [
b100 ]
b0 ^
b0 a
1"
#2
0"
1#
#3
0$
b101 1
b101 O
b101 U
b101 b
b101 f
b101 &
b101 >
b101 H
b101 J
b101 \
16
10
b101 Q
b101 S
b10 7
b10 C
b101 -
b101 ;
b101 @
b101 N
b101 c
b101 4
b101 B
b10011 8
b10011 F
b10100000000000100010011 +
b10100000000000100010011 9
b10100000000000100010011 G
b10100000000000100010011 [
b1000 _
b1000 `
b1000 ]
b100 ^
b100 a
1"
#4
0"
#5
1$
b0 1
b0 O
b0 U
b0 b
b0 f
b0 Q
b0 S
b10 2
b10 =
b10 I
b10 K
b10 V
b0 &
b0 >
b0 H
b0 J
b0 \
16
00
b100 7
b100 C
b0 -
b0 ;
b0 @
b0 N
b0 c
b10 4
b10 B
b10 5
b10 A
b110011 8
b110011 F
b1000010000001000110011 +
b1000010000001000110011 9
b1000010000001000110011 G
b1000010000001000110011 [
b1100 _
b1100 `
b1100 ]
b1000 ^
b1000 a
1"
#6
0"
#7
x$
bx 1
bx O
bx U
bx b
bx f
b0 2
b0 =
b0 I
b0 K
b0 V
06
bx Y
b0xxxxxxx X
bx Q
bx S
bx ,
bx :
bx L
bx W
bx 7
bx C
bx -
bx ;
bx @
bx N
bx c
bx 4
bx B
bx .
bx <
bx ?
bx M
bx R
bx 5
bx A
bx 8
bx F
bx +
bx 9
bx G
bx [
b10000 _
b10000 `
b10000 ]
b1100 ^
b1100 a
1"
#8
0"
#9
b10100 _
b10100 `
b10100 ]
b10000 ^
b10000 a
1"
#10
0"
#11
b11000 _
b11000 `
b11000 ]
b10100 ^
b10100 a
1"
#12
0"
#13
b11100 _
b11100 `
b11100 ]
b11000 ^
b11000 a
1"
#14
$dumpoff
bx h
bx g
bx f
bx e
bx d
bx c
bx b
bx a
bx `
bx _
bx ^
bx ]
bx \
bx [
bx Z
bx Y
bx X
bx W
bx V
bx U
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
bx E
bx D
bx C
bx B
bx A
bx @
bx ?
bx >
bx =
bx <
bx ;
bx :
bx 9
bx 8
bx 7
x6
bx 5
bx 4
bx 3
bx 2
bx 1
x0
x/
bx .
bx -
bx ,
bx +
x*
x)
x(
bx '
bx &
bx %
x$
x#
x"
bx !
$end
