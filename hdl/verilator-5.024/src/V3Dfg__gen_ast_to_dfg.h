// Generated by astgen // -*- mode: C++; c-file-style: "cc-mode" -*-
void visit(AstAcosD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgAcosD* const vtxp = makeVertex<DfgAcosD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAcoshD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgAcoshD* const vtxp = makeVertex<DfgAcoshD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAdd* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgAdd* const vtxp = makeVertex<DfgAdd>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAddD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgAddD* const vtxp = makeVertex<DfgAddD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAnd* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgAnd* const vtxp = makeVertex<DfgAnd>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstArraySel* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgArraySel* const vtxp = makeVertex<DfgArraySel>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAsinD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgAsinD* const vtxp = makeVertex<DfgAsinD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAsinhD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgAsinhD* const vtxp = makeVertex<DfgAsinhD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAssocSel* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgAssocSel* const vtxp = makeVertex<DfgAssocSel>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAtan2D* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgAtan2D* const vtxp = makeVertex<DfgAtan2D>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAtanD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgAtanD* const vtxp = makeVertex<DfgAtanD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAtanhD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgAtanhD* const vtxp = makeVertex<DfgAtanhD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstAtoN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgAtoN* const vtxp = makeVertex<DfgAtoN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstBitsToRealD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgBitsToRealD* const vtxp = makeVertex<DfgBitsToRealD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstBufIf1* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgBufIf1* const vtxp = makeVertex<DfgBufIf1>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCAwait* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCAwait* const vtxp = makeVertex<DfgCAwait>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCCast* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCCast* const vtxp = makeVertex<DfgCCast>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCLog2* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCLog2* const vtxp = makeVertex<DfgCLog2>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCastDynamic* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgCastDynamic* const vtxp = makeVertex<DfgCastDynamic>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCastWrap* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCastWrap* const vtxp = makeVertex<DfgCastWrap>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCeilD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCeilD* const vtxp = makeVertex<DfgCeilD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCompareNN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgCompareNN* const vtxp = makeVertex<DfgCompareNN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstConcat* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgConcat* const vtxp = makeVertex<DfgConcat>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstConcatN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgConcatN* const vtxp = makeVertex<DfgConcatN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCond* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgCond* const vtxp = makeVertex<DfgCond>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCondBound* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgCondBound* const vtxp = makeVertex<DfgCondBound>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCosD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCosD* const vtxp = makeVertex<DfgCosD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCoshD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCoshD* const vtxp = makeVertex<DfgCoshD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCountOnes* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCountOnes* const vtxp = makeVertex<DfgCountOnes>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstCvtPackString* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgCvtPackString* const vtxp = makeVertex<DfgCvtPackString>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDistChiSquare* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgDistChiSquare* const vtxp = makeVertex<DfgDistChiSquare>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDistErlang* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgDistErlang* const vtxp = makeVertex<DfgDistErlang>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDistExponential* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgDistExponential* const vtxp = makeVertex<DfgDistExponential>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDistNormal* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgDistNormal* const vtxp = makeVertex<DfgDistNormal>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDistPoisson* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgDistPoisson* const vtxp = makeVertex<DfgDistPoisson>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDistT* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgDistT* const vtxp = makeVertex<DfgDistT>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDistUniform* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgDistUniform* const vtxp = makeVertex<DfgDistUniform>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDiv* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgDiv* const vtxp = makeVertex<DfgDiv>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDivD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgDivD* const vtxp = makeVertex<DfgDivD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstDivS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgDivS* const vtxp = makeVertex<DfgDivS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstEq* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgEq* const vtxp = makeVertex<DfgEq>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstEqCase* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgEqCase* const vtxp = makeVertex<DfgEqCase>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstEqD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgEqD* const vtxp = makeVertex<DfgEqD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstEqN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgEqN* const vtxp = makeVertex<DfgEqN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstEqT* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgEqT* const vtxp = makeVertex<DfgEqT>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstEqWild* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgEqWild* const vtxp = makeVertex<DfgEqWild>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstExpD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgExpD* const vtxp = makeVertex<DfgExpD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstExtend* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgExtend* const vtxp = makeVertex<DfgExtend>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstExtendS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgExtendS* const vtxp = makeVertex<DfgExtendS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstFEof* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgFEof* const vtxp = makeVertex<DfgFEof>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstFGetC* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgFGetC* const vtxp = makeVertex<DfgFGetC>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstFGetS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgFGetS* const vtxp = makeVertex<DfgFGetS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstFUngetC* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgFUngetC* const vtxp = makeVertex<DfgFUngetC>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstFloorD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgFloorD* const vtxp = makeVertex<DfgFloorD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGetcN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGetcN* const vtxp = makeVertex<DfgGetcN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGetcRefN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGetcRefN* const vtxp = makeVertex<DfgGetcRefN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGt* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGt* const vtxp = makeVertex<DfgGt>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGtD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGtD* const vtxp = makeVertex<DfgGtD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGtN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGtN* const vtxp = makeVertex<DfgGtN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGtS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGtS* const vtxp = makeVertex<DfgGtS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGte* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGte* const vtxp = makeVertex<DfgGte>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGteD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGteD* const vtxp = makeVertex<DfgGteD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGteN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGteN* const vtxp = makeVertex<DfgGteN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstGteS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgGteS* const vtxp = makeVertex<DfgGteS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstHypotD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgHypotD* const vtxp = makeVertex<DfgHypotD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstISToRD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgISToRD* const vtxp = makeVertex<DfgISToRD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstIToRD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgIToRD* const vtxp = makeVertex<DfgIToRD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstIsUnbounded* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgIsUnbounded* const vtxp = makeVertex<DfgIsUnbounded>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstIsUnknown* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgIsUnknown* const vtxp = makeVertex<DfgIsUnknown>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLenN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgLenN* const vtxp = makeVertex<DfgLenN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLog10D* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgLog10D* const vtxp = makeVertex<DfgLog10D>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLogAnd* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogAnd* const vtxp = makeVertex<DfgLogAnd>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLogD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgLogD* const vtxp = makeVertex<DfgLogD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLogEq* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogEq* const vtxp = makeVertex<DfgLogEq>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLogIf* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogIf* const vtxp = makeVertex<DfgLogIf>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLogNot* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgLogNot* const vtxp = makeVertex<DfgLogNot>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLogOr* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLogOr* const vtxp = makeVertex<DfgLogOr>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLt* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLt* const vtxp = makeVertex<DfgLt>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLtD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLtD* const vtxp = makeVertex<DfgLtD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLtN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLtN* const vtxp = makeVertex<DfgLtN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLtS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLtS* const vtxp = makeVertex<DfgLtS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLte* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLte* const vtxp = makeVertex<DfgLte>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLteD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLteD* const vtxp = makeVertex<DfgLteD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLteN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLteN* const vtxp = makeVertex<DfgLteN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstLteS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgLteS* const vtxp = makeVertex<DfgLteS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstModDiv* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgModDiv* const vtxp = makeVertex<DfgModDiv>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstModDivS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgModDivS* const vtxp = makeVertex<DfgModDivS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstMul* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgMul* const vtxp = makeVertex<DfgMul>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstMulD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgMulD* const vtxp = makeVertex<DfgMulD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstMulS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgMulS* const vtxp = makeVertex<DfgMulS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNToI* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgNToI* const vtxp = makeVertex<DfgNToI>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNegate* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgNegate* const vtxp = makeVertex<DfgNegate>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNegateD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgNegateD* const vtxp = makeVertex<DfgNegateD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNeq* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeq* const vtxp = makeVertex<DfgNeq>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNeqCase* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeqCase* const vtxp = makeVertex<DfgNeqCase>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNeqD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeqD* const vtxp = makeVertex<DfgNeqD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNeqN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeqN* const vtxp = makeVertex<DfgNeqN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNeqT* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeqT* const vtxp = makeVertex<DfgNeqT>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNeqWild* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgNeqWild* const vtxp = makeVertex<DfgNeqWild>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNot* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgNot* const vtxp = makeVertex<DfgNot>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstNullCheck* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgNullCheck* const vtxp = makeVertex<DfgNullCheck>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstOneHot* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgOneHot* const vtxp = makeVertex<DfgOneHot>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstOneHot0* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgOneHot0* const vtxp = makeVertex<DfgOneHot0>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstOr* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgOr* const vtxp = makeVertex<DfgOr>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPostAdd* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgPostAdd* const vtxp = makeVertex<DfgPostAdd>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPostSub* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgPostSub* const vtxp = makeVertex<DfgPostSub>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPow* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgPow* const vtxp = makeVertex<DfgPow>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPowD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgPowD* const vtxp = makeVertex<DfgPowD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPowSS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgPowSS* const vtxp = makeVertex<DfgPowSS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPowSU* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgPowSU* const vtxp = makeVertex<DfgPowSU>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPowUS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgPowUS* const vtxp = makeVertex<DfgPowUS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPreAdd* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgPreAdd* const vtxp = makeVertex<DfgPreAdd>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPreSub* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgPreSub* const vtxp = makeVertex<DfgPreSub>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstPutcN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgPutcN* const vtxp = makeVertex<DfgPutcN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstRToIRoundS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgRToIRoundS* const vtxp = makeVertex<DfgRToIRoundS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstRToIS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgRToIS* const vtxp = makeVertex<DfgRToIS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstRealToBits* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgRealToBits* const vtxp = makeVertex<DfgRealToBits>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstRedAnd* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgRedAnd* const vtxp = makeVertex<DfgRedAnd>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstRedOr* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgRedOr* const vtxp = makeVertex<DfgRedOr>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstRedXor* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgRedXor* const vtxp = makeVertex<DfgRedXor>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstReplicate* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgReplicate* const vtxp = makeVertex<DfgReplicate>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstReplicateN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgReplicateN* const vtxp = makeVertex<DfgReplicateN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstResizeLValue* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgResizeLValue* const vtxp = makeVertex<DfgResizeLValue>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstShiftL* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftL* const vtxp = makeVertex<DfgShiftL>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstShiftLOvr* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftLOvr* const vtxp = makeVertex<DfgShiftLOvr>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstShiftR* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftR* const vtxp = makeVertex<DfgShiftR>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstShiftROvr* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftROvr* const vtxp = makeVertex<DfgShiftROvr>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstShiftRS* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftRS* const vtxp = makeVertex<DfgShiftRS>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstShiftRSOvr* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgShiftRSOvr* const vtxp = makeVertex<DfgShiftRSOvr>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSigned* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgSigned* const vtxp = makeVertex<DfgSigned>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSinD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgSinD* const vtxp = makeVertex<DfgSinD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSinhD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgSinhD* const vtxp = makeVertex<DfgSinhD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSliceSel* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgSliceSel* const vtxp = makeVertex<DfgSliceSel>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSqrtD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgSqrtD* const vtxp = makeVertex<DfgSqrtD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstStreamL* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgStreamL* const vtxp = makeVertex<DfgStreamL>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstStreamR* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgStreamR* const vtxp = makeVertex<DfgStreamR>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSub* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgSub* const vtxp = makeVertex<DfgSub>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSubD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgSubD* const vtxp = makeVertex<DfgSubD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstSubstrN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");
    iterate(nodep->op3p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op3p()->user1p(), nodep, "Child 3 missing Dfg vertex");

    DfgSubstrN* const vtxp = makeVertex<DfgSubstrN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<2>(nodep->op3p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstTanD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgTanD* const vtxp = makeVertex<DfgTanD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstTanhD* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgTanhD* const vtxp = makeVertex<DfgTanhD>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstTimeImport* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgTimeImport* const vtxp = makeVertex<DfgTimeImport>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstToLowerN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgToLowerN* const vtxp = makeVertex<DfgToLowerN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstToUpperN* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgToUpperN* const vtxp = makeVertex<DfgToUpperN>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstURandomRange* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgURandomRange* const vtxp = makeVertex<DfgURandomRange>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstUnsigned* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");

    DfgUnsigned* const vtxp = makeVertex<DfgUnsigned>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstWildcardSel* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgWildcardSel* const vtxp = makeVertex<DfgWildcardSel>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstWordSel* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgWordSel* const vtxp = makeVertex<DfgWordSel>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
void visit(AstXor* nodep) override {
    UASSERT_OBJ(!nodep->user1p(), nodep, "Already has Dfg vertex");

    if (unhandled(nodep)) return;

    iterate(nodep->op1p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op1p()->user1p(), nodep, "Child 1 missing Dfg vertex");
    iterate(nodep->op2p());
    if (m_foundUnhandled) return;
    UASSERT_OBJ(nodep->op2p()->user1p(), nodep, "Child 2 missing Dfg vertex");

    DfgXor* const vtxp = makeVertex<DfgXor>(nodep, *m_dfgp);
    if (!vtxp) {
        m_foundUnhandled = true;
        ++m_ctx.m_nonRepNode;
        return;
    }

    vtxp->relinkSource<0>(nodep->op1p()->user1u().to<DfgVertex*>());
    vtxp->relinkSource<1>(nodep->op2p()->user1u().to<DfgVertex*>());

    m_uncommittedVertices.push_back(vtxp);
    nodep->user1p(vtxp);
}
